[{"fileName":"getting-started.html","title":"Getting started","body":"<p>useElven is a set of hooks and tools designed to work with React-base applications.</p> <p>The tool is a wrapper for <a href=\"https://docs.multiversx.com/sdk-and-tools/sdk-js/\">sdk-js</a> - a set of Typescript/Javascript libraries.</p> <h2>What useElven can do?</h2> <p>The fundamental functionality is connecting and logging the user using auth providers. useElven supports all of <a href=\"https://docs.multiversx.com/sdk-and-tools/sdk-js/sdk-js-signing-providers\">4 signing providers</a>.</p> <p>There is also an option to pass a unique token and get a signature after authentication, which you can use for additional backend verification.</p> <p>Besides authentication, useElven will also help with all the interactions, like sending native $EGLD tokens or even ESDT tokens. It will allow you to make most transactions, including interactions with custom smart contracts. There is also a possibility to query smart contracts. With an ABI file, you can also decode returned data using React hooks.</p> <h2>How to start using it?</h2> <p>Add useElven to your project:</p> <pre><code>npm install @useelven/core --save </code></pre> <p>Then import in React app. For example:</p> <pre><code class=\"language-jsx\">import { useNetworkSync } from '@useelven/core'; </code></pre> <p>Initialize:</p> <pre><code class=\"language-jsx\">import { useNetworkSync } from '@useelven/core';  const NextJSDappTemplate = ({ Component, pageProps }: AppProps) => {    useNetworkSync({ chainType: 'devnet' });    return (     &#x3C;ChakraProvider theme={theme}>       &#x3C;Component {...pageProps} />     &#x3C;/ChakraProvider>   ); }; </code></pre> <p>Login:</p> <pre><code class=\"language-jsx\">import { useLogin } from '@useelven/core';  (...)  const { login, isLoggedIn, error } = useLogin({   token: 'some_hash_here', }); </code></pre> <p>Sign and send transaction:</p> <pre><code class=\"language-jsx\">import { useTransaction } from '@useelven/core'; import { TransactionPayload, TokenTransfer } from '@multiversx/sdk-core';  (...)  const { pending, triggerTx, transaction, txResult, error } = useTransaction();  const handleSendTx = () => {   const demoMessage = 'Transaction demo!';   triggerTx({     address: 'erd123.....',     gasLimit: 50000 + 1500 * demoMessage.length,     data: new TransactionPayload(demoMessage),     value: TokenTransfer.egldFromBigInteger(1_000_000_000_000_000_000),   }); }; </code></pre> <p>The tools should work with most React setups. For example, with Next.js or React + Vite. But each of the setups requires some additional configuration. This is why there are demo templates that you can clone and treat as a base for your app.</p> <div class=\"docs-box docs-info-box\">You should always use transaction hooks when you are sure that you are in a signed-in context</div> <h2>Summary</h2> <p>Okay, so you know what useElven is and how to start using it. You are now ready to look at the <a href=\"/docs/sdk-reference.html\">SDK reference</a>.</p>","excerpt":"A set of tools for React-based apps using MultiversX JS SDK","publicationDate":"2023-02-12","tags":["intro"],"coverImage":""},{"fileName":"sdk-reference.html","title":"SDK Reference","body":"<p><strong>Please be aware that the docs will be improved in the following days!</strong></p> <p>The code samples are not ready to copy and paste. Please search for them in the code of the demo apps linked on the homepage.</p> <h4>useNetworkSync()</h4> <p>The hook is responsible for synchronizing the network on each refresh. It should be used in the root component. Here is the <code>_app.tsx</code> in Next.js app.</p> <pre><code class=\"language-jsx\">import { useNetworkSync } from '@useelven/core';  const NextJSDappTemplate = ({ Component, pageProps }: AppProps) => {    useNetworkSync({     chainType: 'devnet',     // If you want to use xPortal signing,      // you would need to configure your Wallet Connect project id here: https://cloud.walletconnect.com     walletConnectV2ProjectId: '&#x3C;your_wallet_connect_project_id_here>'   });    return (     &#x3C;ChakraProvider theme={theme}>       &#x3C;Component {...pageProps} />     &#x3C;/ChakraProvider>   ); }; </code></pre> <p>Configuration options in <code>useNetworkSync</code>:</p> <pre><code class=\"language-typescript\">chainType?: string; shortId?: string; name?: string; egldLabel?: string; egldDenomination?: string; decimals?: string; gasPerDataByte?: string; walletConnectDeepLink?: string; walletAddress?: string; apiAddress?: string; explorerAddress?: string; IPFSGateway?: string; apiTimeout?: string; walletConnectV2RelayAddresses?: string[]; walletConnectV2ProjectId?: string; </code></pre> <p>You can overwrite each of the settings. But when you don't overwrite all of them and overwrite the <code>chainType</code>, all other values will default by the <code>chainType</code>. You can find all defaults <a href=\"https://github.com/useElven/core/blob/wallet-connect-2/src/config/network.ts\">here</a>.</p> <p>So, for example, when you set the <code>chainType</code> to <code>testnet</code>, and <code>apiTimeout</code> to <code>10000</code> and nothing more. Then you will get all default settings for the testnet, like the API endpoint, <code>testnet-api.multiversx.com</code>, but the <code>apiTimeout</code> will be kept at <code>10000</code>.</p> <h4>useLogin</h4> <p>It is the main hook for logging in. The hook is one for all auth providers and can take the auth token as an argument. It can be by any string. Based on this, the auth signature will be generated. This is required when you verify the user account on the backend side.</p> <pre><code class=\"language-jsx\">import { useLogin } from '@useelven/core';  (...)  const { login, isLoggedIn, error, walletConnectUri, getHWAccounts } = useLogin({   token: 'some_hash_here', }); </code></pre> <h4>useTransaction()</h4> <p>The hook provides all that is required for triggering transactions. useTransaction can also take a callback function as an argument.</p> <div class=\"docs-box docs-info-box\">You should always use transaction hooks when you are sure that you are in a signed-in context</div> <pre><code class=\"language-jsx\">import { useTransaction } from '@useelven/core'; import { TransactionPayload, TokenTransfer } from '@multiversx/sdk-core';  (...)  const { pending, triggerTx, transaction, txResult, error } = useTransaction({ cb });  const handleSendTx = () => {   const demoMessage = 'Transaction demo!';   triggerTx({     address: 'erd123.....',     gasLimit: 50000 + 1500 * demoMessage.length,     data: new TransactionPayload(demoMessage),     value: TokenTransfer.egldFromBigInteger(1_000_000_000_000_000_000),   }); }; </code></pre> <p>Example with Smart Contract data payload. For example, when you want to call an endpoint on a custom smart contract.</p> <pre><code class=\"language-jsx\">import { useTransaction } from '@useelven/core'; import { U32Value, ContractFunction, ContractCallPayloadBuilder } from '@multiversx/sdk-core';  (...)  const { triggerTx } = useTransaction();  const handleSendTx = () => {   const data = new ContractCallPayloadBuilder()     .setFunction(new ContractFunction('mint'))     .setArgs([new U32Value(1)])     .build();    triggerTx({     address: 'erd123.....',     gasLimit: 14000000,     value: TokenTransfer.egldFromBigInteger(1_000_000_000_000_000_000),     data   }); }; </code></pre> <h4>useScQuery()</h4> <p>The hook uses useSWR under the hood and can be triggered on a component mount or remotely on some action. It has two different states for the pending action. For initial load and on revalidate. It also takes one of three return data types: 'number', 'string', 'boolean'. For now, it assumes that you know what data type will be returned by a smart contract. Later it will get more advanced functionality.</p> <pre><code class=\"language-jsx\">import { SCQueryType, useScQuery } from '@useelven/core';  (...)  const {   data: queryResult,   fetch, // you can always trigger the query manually if 'autoInit' is set to false   isLoading, // pending state for initial load   isValidating, // pending state for each revalidation of the data, for example using the mutate   error, } = useScQuery&#x3C;number>({   type: SCQueryType.NUMBER, // can be NUMBER, STRING, BOOLEAN or COMPLEX   payload: {     scAddress: 'erd123....',     funcName: 'getSomethingBySomething',     args: [], // arguments for the query in hex format, you can use sdk-core for that, for example: args: [ new Address('erd1....').hex() ] etc. It will be also simplified in the future.   },   autoInit: false, // you can enable or disable the trigger of the query on the component mount   abiJSON: yourImportedAbiJSONObject // required for SCQueryType.COMPLEX type }); </code></pre> <p><strong>Example</strong> with <code>SCQueryType.COMPLEX</code>. This type uses <code>/vm-values/query</code>, ABI and ResultParser. The ABI JSON contents are required here. You can copy abi.json and import it in the same place you use useScQuery. Put the abi JSON file wherever you like in the codebase. I chose the <code>config</code> directory. See the example below:</p> <pre><code class=\"language-jsx\">import { TypedOutcomeBundle } from '@multiversx/sdk-core'; import abiJSON from '../config/abi.json'; // you need to be able to load JSON files in React app  const { data } = useScQuery&#x3C;TypedOutcomeBundle>({   type: SCQueryType.COMPLEX,   payload: {     scAddress: 'erd1qqq...',     funcName: 'yourScFunction',     args: [], // args in hex format, use sdk-core for conversion, see above   },   autoInit: true,   abiJSON, }); </code></pre> <p>The <code>data</code> here will be a <code>TypedOutcomeBundle</code>. Which is:</p> <pre><code class=\"language-typescript\">interface TypedOutcomeBundle {   returnCode: ReturnCode;   returnMessage: string;   values: TypedValue[];   firstValue?: TypedValue;   secondValue?: TypedValue;   thirdValue?: TypedValue;   lastValue?: TypedValue; } </code></pre> <p>You can then process the data. For example <code>data.firstValue.valueOf()</code> or <code>data.firstValue.toString()</code> if applicable. The returned type can be further processed using <a href=\"https://github.com/multiversx/mx-sdk-js-core\">sdk-core</a>.</p> <h4>useLoggingIn()</h4> <p>The hook will provide information about the authentication flow state. It will tell if the user is already logged in or is logging in.</p> <pre><code class=\"language-jsx\">import { useLoggingIn } from '@useelven/core';  (...)  const { isLoggingIn, error, isLoggedIn } = useLoggingIn(); </code></pre> <h4>useAccount()</h4> <p>The hook will provide information about the user's account data state. The data: address, nonce, balance.</p> <pre><code class=\"language-jsx\">import { useAccount } from '@useelven/core';  (...)  const { address, nonce, balance } = useAccount(); </code></pre> <h4>useLoginInfo()</h4> <p>The hook will provide information about the user's auth data state. The data: loginMethod, expires, loginToken, signature. Login token and signature won't always be there. It depends if you'll use the token. Check <a href=\"https://www.elven.tools/docs/dapp-backend-integration.html\">Elven Tools Dapp backend integration article</a> for more info.</p> <pre><code class=\"language-jsx\">import { useLoginInfo } from '@useelven/core';  (...)  const { loginMethod, expires, loginToken, signature } = useLoginInfo(); </code></pre> <h4>useApiCall()</h4> <p>The hook provides a convenient way of doing custom API calls unrelated to transactions or smart contract queries. By default, it will use MultiversX API endpoint. But it can be any type of API, not only MultiversX API. In that case, you would need to pass the <code>{ baseEndpoint: \"https://some-api.com\" }</code></p> <pre><code class=\"language-jsx\">const { data, isLoading, isValidating, fetch, error } = useApiCall&#x3C;Token[]>({   url: `/accounts/&#x3C;some_erd_address_here>/tokens`, // can be any API path without the host, because the host is already handled internally   autoInit: true, // similar to useScQuery   type: 'get', // can be get, post, delete, put   payload: {},   options: {}   baseEndpoint: undefined, // any custom API endpoint, by default MultiversX API }); </code></pre> <p>   You can pass the response type. Returned object is the same as in <code>useScQuery</code>   The hook uses <code>swr</code> and native <code>fetch</code> under the hood. </p> <h4>More to come</h4> <p>There will more of them for sure. Some of the hooks will land in separate repositories/packages. Stay tuned!</p>","excerpt":"A set of tools for React-based apps using MultiversX JS SDK","publicationDate":"2022-09-20","tags":["intro"],"coverImage":""}]