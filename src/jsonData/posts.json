[{"fileName":"getting-started.html","title":"Getting started","body":"<p>useElven is a set of hooks and tools designed to work with React-base applications.</p> <p>The tool is a wrapper for <a href=\"https://docs.multiversx.com/sdk-and-tools/sdk-js/\">sdk-js</a> - a set of Typescript/Javascript libraries.</p> <h2>What useElven can do?</h2> <p>The fundamental functionality is connecting and logging the user using auth providers. useElven supports all of <a href=\"https://docs.multiversx.com/sdk-and-tools/sdk-js/sdk-js-signing-providers\">4 signing providers</a>.</p> <p>By default useElven uses <a href=\"https://www.npmjs.com/package/@multiversx/sdk-native-auth-client\">@multiversx/sdk-native-auth-client</a> under the hood.</p> <p>Besides authentication, useElven will also help with all the interactions, like sending native $EGLD tokens or even ESDT tokens. It will allow you to make most transactions, including interactions with custom smart contracts. There is also a possibility to query smart contracts. With an ABI file, you can also decode returned data using React hooks.</p> <h2>How to start using it?</h2> <div class=\"docs-box docs-info-box\">Just to let you know, integrating it with frameworks needs some additional configuration. You'll find examples in ready-to-use starter templates: <a href=\"https://github.com/useElven/react-vite\" target=\"_blank\">Vite + React</a> and <a href=\"https://github.com/xdevguild/nextjs-dapp-template\" target=\"_blank\">Next.js template</a>. Check the configuration files in both.</div> <p>Add useElven to your project:</p> <pre><code>npm install @useelven/core --save </code></pre> <p>Then import in React app. For example:</p> <pre><code class=\"language-jsx\">import { useNetworkSync } from '@useelven/core'; </code></pre> <p>Initialize:</p> <pre><code class=\"language-jsx\">import { useNetworkSync } from '@useelven/core';  const NextJSDappTemplate = ({ Component, pageProps }: AppProps) => {    useNetworkSync({ chainType: 'devnet' });    return (     &#x3C;Component {...pageProps} />   ); }; </code></pre> <p>Login:</p> <pre><code class=\"language-jsx\">import { useLogin } from '@useelven/core';  (...)  const { login, isLoggedIn, error } = useLogin(); </code></pre> <p>Sign and send transaction:</p> <pre><code class=\"language-jsx\">import { useTransaction } from '@useelven/core'; import { TransactionPayload, TokenTransfer } from '@multiversx/sdk-core';  (...)  const { pending, triggerTx, transaction, txResult, error } = useTransaction();  const handleSendTx = () => {   const demoMessage = 'Transaction demo!';   triggerTx({     address: 'erd123.....',     // additional 50000 will be added internally when working with guarded accounts     gasLimit: 50000 + 1500 * demoMessage.length,      data: new TransactionPayload(demoMessage),     value: TokenTransfer.egldFromBigInteger(1_000_000_000_000_000_000),   }); }; </code></pre> <p>The tools should work with most React setups. For example, with Next.js or React + Vite. But each of the setups requires some additional configuration. This is why there are demo templates that you can clone and treat as a base for your app.</p> <div class=\"docs-box docs-info-box\">You should always use transaction hooks when you are sure that you are in a signed-in context</div> <h2>Summary</h2> <p>Okay, so you know what useElven is and how to start using it. You are now ready to look at the <a href=\"/docs/sdk-reference.html\">SDK reference</a>.</p>","excerpt":"A set of tools for React-based apps using MultiversX JS SDK","publicationDate":"2023-02-12","tags":["intro"],"coverImage":""},{"fileName":"sdk-reference.html","title":"SDK Reference","body":"<div class=\"docs-box docs-info-box\">The code samples are not ready to copy and paste. Please search for them in the code of the demo apps: <a href=\"https://github.com/useElven/react-vite\" target=\"_blank\">Vite + React</a> and <a href=\"https://github.com/xdevguild/nextjs-dapp-template\" target=\"_blank\">Next.js template</a>. Also, please check the configuration files in both.</div> <h4>useNetworkSync()</h4> <p>The hook is responsible for synchronizing the network on each refresh. It should be used in the root component. Here is the <code>_app.tsx</code> in Next.js app.</p> <pre><code class=\"language-jsx\">import { useNetworkSync } from '@useelven/core';  const NextJSDappTemplate = ({ Component, pageProps }: AppProps) => {    useNetworkSync({     chainType: 'devnet',     // If you want to use xPortal signing,      // you would need to configure your Wallet Connect project id here: https://cloud.walletconnect.com     walletConnectV2ProjectId: '&#x3C;your_wallet_connect_project_id_here>'   });    return (     &#x3C;Component {...pageProps} />   ); }; </code></pre> <p>Configuration options in <code>useNetworkSync</code>:</p> <pre><code class=\"language-typescript\">chainType?: string; shortId?: string; name?: string; egldLabel?: string; egldDenomination?: string; decimals?: string; gasPerDataByte?: string; walletConnectDeepLink?: string; xAliasAddress?: string; walletAddress?: string; apiAddress?: string; explorerAddress?: string; IPFSGateway?: string; apiTimeout?: string; txWatcherTimeout?: string; txWatcherPatience?: string; walletConnectV2RelayAddresses?: string[]; walletConnectV2ProjectId?: string; </code></pre> <p>You can overwrite each of the settings. But when you don't overwrite all of them and overwrite the <code>chainType</code>, all other values will default by the <code>chainType</code>. You can find all defaults <a href=\"https://github.com/useElven/core/blob/main/src/config/network.ts\">here</a>.</p> <p>So, for example, when you set the <code>chainType</code> to <code>testnet</code>, and <code>apiTimeout</code> to <code>10000</code> and nothing more. Then you will get all default settings for the testnet, like the API endpoint, <code>testnet-api.multiversx.com</code>, but the <code>apiTimeout</code> will be kept at <code>10000</code>.</p> <h4>useLogin</h4> <p>It is the main hook for logging in. By default useElven uses <a href=\"https://www.npmjs.com/package/@multiversx/sdk-native-auth-client\">@multiversx/sdk-native-auth-client</a> under the hood.</p> <pre><code class=\"language-jsx\">import { useLogin, LoginMethodsEnum } from '@useelven/core';  (...)  const {   login,   isLoggedIn,   error,   walletConnectUri,   getHWAccounts } = useLogin();  (...)  login(LoginMethodsEnum.extension); </code></pre> <p>where:</p> <pre><code class=\"language-ts\">enum LoginMethodsEnum {   ledger = \"ledger\",   walletconnect = \"walletconnect\",   wallet = \"wallet\",   extension = \"extension\",   xalias = \"xalias\",   extra = \"extra\",   none = \"\" } </code></pre> <h4>useTransaction()</h4> <p>The hook provides all that is required for triggering transactions. useTransaction can also take a callback function as an argument.</p> <div class=\"docs-box docs-info-box\">You should always use transaction hooks when you are sure that you are in a signed-in context (Check Authenticated component in <a href=\"https://github.com/xdevguild/nextjs-dapp-template\">Next.js Dapp Template</a>).</div> <pre><code class=\"language-jsx\">import { useTransaction } from '@useelven/core'; import { TransactionPayload, TokenTransfer } from '@multiversx/sdk-core';  (...)  const {   pending,   triggerTx,   transaction, // transaction data before signing   txResult, // transaction result on chain   error } = useTransaction({ id, cb, callbackUrl });  const handleSendTx = () => {   const demoMessage = 'Transaction demo!';   triggerTx({     address: 'erd123.....',     // additional 50000 will be added internally when working with guarded accounts     gasLimit: 50000 + 1500 * demoMessage.length,     data: new TransactionPayload(demoMessage),     value: TokenTransfer.egldFromBigInteger(1_000_000_000_000_000_000),   }); }; </code></pre> <p>Example with Smart Contract data payload. For example, when you want to call an endpoint on a custom smart contract.</p> <pre><code class=\"language-jsx\">import { useTransaction } from '@useelven/core'; import { U32Value, ContractFunction, ContractCallPayloadBuilder } from '@multiversx/sdk-core';  (...)  const { triggerTx } = useTransaction();  const handleSendTx = () => {   const data = new ContractCallPayloadBuilder()     .setFunction(new ContractFunction('mint'))     .setArgs([new U32Value(1)])     .build();    triggerTx({     address: 'erd123.....',     gasLimit: 14000000,     value: TokenTransfer.egldFromBigInteger(1_000_000_000_000_000_000),     data   }); }; </code></pre> <p>Params:</p> <ul>   <li><code>id</code> - custom ID for a transaction. It is helpful when there is a need to have multiple calls on the same view, especially for web wallet redirections, but generally it is optional</li>   <li><code>cb</code> - optional callback function</li>   <li><code>callbackUrl</code> - optional redirect url when using Web Wallet, default <code>/</code></li> </ul> <p>   <strong>Important</strong>   From version 0.11.0, you can also pass whole Transaction object to the <code>triggerTx</code>. It is helpful when you need some custom Transaction logic and builders. </p> <p>It could look like:</p> <pre><code class=\"language-jsx\"> triggerTx({   tx: transactionObject }); </code></pre> <p>Where <code>transactionObject</code> is your Transaction object, the same as type as the one prepared in <code>triggerTx</code>.</p> <h4>useTokenTransfer()</h4> <p>The hook is a wrapper over the <code>useTransaction</code>. It is designed to simplify transferring ESDT tokens (so fungible, NFT, SFT, meta). You can send them between standard addresses and to a smart contract. You can also call a smart contract endpoint and pass the required parameters.</p> <div class=\"docs-box docs-info-box\">You should always use transaction hooks when you are sure that you are in a signed-in context (Check Authenticated component in <a href=\"https://github.com/xdevguild/nextjs-dapp-template\">Next.js Dapp Template</a>).</div> <p>Example: we send the fungible tokens to a faucet smart contract, and we want to call the <code>setLimit</code> endpoint, which is responsible for setting the daily claim limit. You can check the code <a href=\"https://github.com/xdevguild/esdt-faucet-dapp\">here</a>.</p> <pre><code class=\"language-jsx\">import { BigUIntValue } from '@multiversx/sdk-core'; import { useTokenTransfer, ESDTType } from '@useelven/core';  (...)  const {   pending,    transfer,   transaction, // transaction data before signing   txResult, // transaction result on chain   error } = useTokenTransfer({ id, cb, callbackUrl }); // useTokenTransfer params are optional, read more about them below  (...)  transfer({   type: ESDTType.FungibleESDT,   tokenId: 'BUILDO-890d14',   receiver: 'erd1qqqqqqqqqqqqqpgqwd59aum8c7c72ces7cezsmhqd8rqrtwagtksp6jahr',   amount: '10', // (here the amount is 10, no need for denomination etc.)   endpointName: 'setLimit', // In this example - faucet limit per day   endpointArgs: [new BigUIntValue('1000000000000000000')], }); </code></pre> <p>Here is another example where we want to send a specific NFT token to the staking smart contract, and at the same time, we want to call the <code>stake</code> endpoint.</p> <pre><code class=\"language-jsx\">import { BigUIntValue } from '@multiversx/sdk-core'; import { useTokenTransfer, ESDTType } from '@useelven/core';  (...)  const {   pending,    transfer,   transaction, // transaction data before signing   txResult, // transaction result on chain   error } = useTokenTransfer({ id, cb, callbackUrl });  (...)  transfer({   type: ESDTType.NonFungibleESDT,   tokenId: 'FCS-12ed15-0c', // token id, not collection id   receiver: 'erd1qqqqqqqqqq...',   endpointName: 'stake', // In this example - we want to call the stake endpoint }); </code></pre> <p>You can also send ESDTs to standard wallet addresses. Omit <code>endpointName</code> and <code>endpointArgs</code>.</p> <p>Params:</p> <ul>   <li><code>id</code> - custom ID for a transaction. It is helpful when there is a need to have multiple calls on the same view, especially for web wallet redirections, but generally it is optional</li>   <li><code>cb</code> - optional callback function</li>   <li><code>callbackUrl</code> - optional redirect url when using Web Wallet, default <code>/</code></li> </ul> <p>ESDTType enum:</p> <pre><code class=\"language-typescript\">enum ESDTType {     FungibleESDT = \"FungibleESDT\",     MetaESDT = \"MetaESDT\",     NonFungibleESDT = \"NonFungibleESDT\",     SemiFungibleESDT = \"SemiFungibleESDT\" } </code></pre> <h4>useMultiTokenTransfer()</h4> <p>The hook is responsible for transferring multiple ESDT tokens (Fungible/Non-fungible/Semi-fungible/Meta). You can also send and call the smart contract endpoint.</p> <p>Example:</p> <pre><code class=\"language-typescript\">(...) const {   pending,    transfer,   transaction, // transaction data before signing   txResult, // transaction result on chain   error } = useMultiTokenTransfer({ id, cb, callbackUrl }); // useMultiTokenTransfer params are optional, read more about them below  (...)  const tokensArr: MultiTransferToken[] = [   {     type: ESDTType.FungibleESDT,     amount: '150',     tokenId: 'FUNG-303171',   },   {     type: ESDTType.SemiFungibleESDT,     amount: '120', // (here the amount is 120, no need for denomination etc.)     tokenId: 'BURN-19ee93-01', // token id, not collection id   },   {     type: ESDTType.MetaESDT,     amount: '10.55', // (here the amount is 10.55)     tokenId: 'META-18r993-01',   },   {     type: ESDTType.NonFungibleESDT,     tokenId: 'ELVEN-14e593-01',   }, ];  transfer({   tokens: tokensArr,   receiver: 'erd1qqqqqqqqqq...', // smart contract address   endpointName: 'burn',   endpointArgs: [], }); (...) </code></pre> <p>You can also send ESDTs to standard wallet addresses. Omit <code>endpointName</code> and <code>endpointArgs</code>.</p> <p>Where <code>tokens</code> is an array of objects with type <code>MultiTransferToken</code> (can be imported from the lib).</p> <p>MultiTransferToken:</p> <pre><code class=\"language-typescript\">{   type: ESDTType;   tokenId: string;   amount: string; } </code></pre> <p>Params:</p> <ul>   <li><code>id</code> - custom ID for a transaction. It is helpful when there is a need to have multiple calls on the same view, especially for web wallet redirections, but generally it is optional</li>   <li><code>cb</code> - optional callback function</li>   <li><code>callbackUrl</code> - optional redirect url when using Web Wallet, default <code>/</code></li> </ul> <p>ESDTType enum:</p> <pre><code class=\"language-typescript\">enum ESDTType {     FungibleESDT = \"FungibleESDT\",     MetaESDT = \"MetaESDT\",     NonFungibleESDT = \"NonFungibleESDT\",     SemiFungibleESDT = \"SemiFungibleESDT\" } </code></pre> <h4>useScQuery()</h4> <p>The hook uses useSWR under the hood and can be triggered on a component mount or remotely on some action. It has two different states for the pending action. For initial load and on revalidate. It also takes one of three return data types: 'number', 'string', 'boolean'. For now, it assumes that you know what data type will be returned by a smart contract. Later it will get more advanced functionality.</p> <pre><code class=\"language-jsx\">import { SCQueryType, useScQuery } from '@useelven/core';  (...)  const {   data: queryResult,   fetch, // you can always trigger the query manually if 'autoInit' is set to false   isLoading, // pending state for initial load   isValidating, // pending state for each revalidation of the data, for example using the mutate   error, } = useScQuery&#x3C;number>({   type: SCQueryType.NUMBER, // can be NUMBER, STRING, BOOLEAN or COMPLEX   payload: {     scAddress: 'erd123....',     funcName: 'getSomethingBySomething',     args: [], // arguments for the query in hex format, you can use sdk-core for that, for example: args: [ new Address('erd1....').hex() ] etc. It will be also simplified in the future.   },   autoInit: false, // you can enable or disable the trigger of the query on the component mount   abiJSON: yourImportedAbiJSONObject // required for SCQueryType.COMPLEX type }); </code></pre> <p><strong>Example</strong> with <code>SCQueryType.COMPLEX</code>. This type uses <code>/vm-values/query</code>, ABI and ResultParser. The ABI JSON contents are required here. You can copy abi.json and import it in the same place you use useScQuery. Put the abi JSON file wherever you like in the codebase. I chose the <code>config</code> directory. See the example below:</p> <pre><code class=\"language-jsx\">import { TypedOutcomeBundle } from '@multiversx/sdk-core'; import abiJSON from '../config/abi.json'; // you need to be able to load JSON files in React app  const { data } = useScQuery&#x3C;TypedOutcomeBundle>({   type: SCQueryType.COMPLEX,   payload: {     scAddress: 'erd1qqq...',     funcName: 'yourScFunction',     args: [], // args in hex format, use sdk-core for conversion, see above   },   autoInit: true,   abiJSON, }); </code></pre> <p>The <code>data</code> here will be a <code>TypedOutcomeBundle</code>. Which is:</p> <pre><code class=\"language-typescript\">interface TypedOutcomeBundle {   returnCode: ReturnCode;   returnMessage: string;   values: TypedValue[];   firstValue?: TypedValue;   secondValue?: TypedValue;   thirdValue?: TypedValue;   lastValue?: TypedValue; } </code></pre> <p>You can then process the data. For example <code>data.firstValue.valueOf()</code> or <code>data.firstValue.toString()</code> if applicable. The returned type can be further processed using <a href=\"https://github.com/multiversx/mx-sdk-js-core\">sdk-core</a>.</p> <h4>useScDeploy()</h4> <p>The hook allows you to deploy a smart contract directly from the provided path to file (also URL) or as an ArrayBuffer.</p> <pre><code class=\"language-jsx\">import { useScDeploy } from '@useelven/core';  (...)  const { deploy, pending, transaction, error, txResult, scAddress } = useScDeploy({ id, cb, callbackUrl });  const handleDeploy = () => {   deploy({ source: '/mysmartcontract.wasm' });   // or:   // deploy({ source: 'https://www.somedomain.com/mysmartcontract.wasm' });   // or:   // const response = await fetch(source);   // const bytes = await response.arrayBuffer();   // deploy({ source: bytes }); };  (...)  // scAddress is computed from the sender's address and nonce, // it will be available immediately // so in your app, the best is to wait for txResult and only then show the scAddress // txResult is transaction data on chain after all processes are finished console.log(scAddress) </code></pre> <p>deploy arguments:</p> <pre><code class=\"language-ts\">export interface ScDeployArgs {   source: Buffer | string;   gasLimit?: number;   codeMetadata?: [boolean, boolean, boolean, boolean];   initArguments?: TypedValue[]; } </code></pre> <p><code>codeMetadata</code> defines the properties of the smart contract which are in order:</p> <pre><code>- `upgradeable` Whether the contract is upgradeable - `readable` Whether other contracts can read this contract's data (without calling one of its pure functions) - `payable` Whether the contract is payable - `payableBySc` Whether the contract is payable by other smart contracts </code></pre> <p>So you need to pass boolean values like <code>[true, true, false, false]</code></p> <p><code>initArguments</code> is a set of TypedValue arguments. For example, if your smart contract needs two arguments in the init function, and they are a BigUint and ManagedBuffer, you could do the following:</p> <pre><code class=\"language-ts\">import { useScDeploy } from '@useelven/core'; import { BigUintValue, BytesValue } from '@multiversx/sdk-core';  (...)  deploy({ source: '/mysmartcontract.wasm', initArguments: [new BigUintValue(100), BytesValue.fromUTF8('Some string')] });  (...) </code></pre> <p>Params:</p> <ul>   <li><code>id</code> - custom ID for a transaction. It is helpful when there is a need to have multiple calls on the same view, especially for web wallet redirections, but generally it is optional</li>   <li><code>cb</code> - optional callback function</li>   <li><code>callbackUrl</code> - optional redirect url when using Web Wallet, default <code>/</code></li> </ul> <p>Check sdk-core lib for more data types helpers.</p> <h4>useSignMessage()</h4> <p>The hook allows you to sign any custom message using your wallet address.</p> <pre><code class=\"language-jsx\">import { useSignMessage } from '@useelven/core';  (...)  const { signMessage, pending, signature } = useSignMessage();  const handleSignMessage = () => {   signMessage({ message: 'Elven Family is awesome!' }); };  (...)  console.log(signature) </code></pre> <p>signMessage arguments:</p> <pre><code class=\"language-ts\">type SignMessageArgs = {   message: string;   options?: {       callbackUrl?: string;   }; }; </code></pre> <h4>useLoggingIn()</h4> <p>The hook will provide information about the authentication flow state. It will tell if the user is already logged in or is logging in.</p> <pre><code class=\"language-jsx\">import { useLoggingIn } from '@useelven/core';  (...)  const { pending, error, loggedIn } = useLoggingIn(); </code></pre> <h4>useAccount()</h4> <p>The hook will provide information about the user's account data state. The data: address, nonce, balance.</p> <pre><code class=\"language-jsx\">import { useAccount } from '@useelven/core';  (...)  const { address, nonce, balance } = useAccount(); </code></pre> <h4>useConfig()</h4> <p>The hook will provide information about curent global configuration.</p> <pre><code class=\"language-jsx\">import { useConfig } from '@useelven/core';  (...)  const {   chainType,   shortId,   name,   egldLabel,   egldDenomination,   decimals,   gasPerDataByte,   walletConnectDeepLink,   xAliasAddress,   walletAddress,   apiAddress,   explorerAddress,   apiTimeout,   txWatcherTimeout,   txWatcherPatience,   IPFSGateway,   walletConnectV2RelayAddresses,   walletConnectV2ProjectId, } = useConfig(); </code></pre> <h4>useNetwork()</h4> <p>The hook will provide the dapp provider and network provider instances. It isn't used much, but in some cases, it can be helpful.</p> <pre><code class=\"language-jsx\">import { useNetwork } from '@useelven/core';  (...)  const { dappProvider, apiNetworkProvider } = useAccount(); </code></pre> <h4>useLoginInfo()</h4> <p>The hook will provide information about the user's auth data state. The data: loginMethod, expires, loginToken, signature, accessToken.</p> <pre><code class=\"language-jsx\">import { useLoginInfo } from '@useelven/core';  (...)  const {   loginMethod,   expires,   loginToken,   signature,   accessToken } = useLoginInfo(); </code></pre> <h4>useApiCall()</h4> <p>The hook provides a convenient way of doing custom API calls unrelated to transactions or smart contract queries. By default, it will use MultiversX API endpoint. But it can be any type of API, not only MultiversX API. In that case, you would need to pass the <code>{ baseEndpoint: \"https://some-api.com\" }</code></p> <pre><code class=\"language-jsx\">const { data, isLoading, isValidating, fetch, error } = useApiCall&#x3C;Token[]>({   url: `/accounts/&#x3C;some_erd_address_here>/tokens`, // can be any API path without the host, because the host is already handled internally   autoInit: true, // similar to useScQuery   type: 'get', // can be get, post, delete, put   payload: {},   options: {}   baseEndpoint: undefined, // any custom API endpoint, by default MultiversX API }); </code></pre> <p>   You can pass the response type. Returned object is the same as in <code>useScQuery</code>   The hook uses <code>swr</code> and native <code>fetch</code> under the hood. </p> <h4>Real life examples:</h4> <p>To get more familiarity with the use Elven library, you can check two open-source projects that use a lot of it:</p> <ul>   <li><a href=\"https://github.com/xdevguild/buildo.dev\">Buildo.dev</a></li>   <li><a href=\"https://github.com/xdevguild/nextjs-dapp-template\">Next.js Dapp Template</a></li>   <li><a href=\"https://github.com/xdevguild/piggy-bank-dapp\">Piggy Bank Dapp</a></li> </ul> <h4>More to come</h4> <p>There will more of them for sure. Some of the hooks will land in separate repositories/packages. Stay tuned!</p>","excerpt":"A set of tools for React-based apps using MultiversX JS SDK","publicationDate":"2022-09-20","tags":["intro"],"coverImage":""}]